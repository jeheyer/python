#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
import traceback
import http.client

env = "prod"

def GetEnvironment(hostname):

    # Pre-Preduction
    if ".htspaces.com" in hostname or "stage.yousendit.com" in hostname:
        if "stage." in hostname:
            return "stage"
        else:
            return hostname.split(".")[1]
    # John Home Test env
    elif "j5.org" in hostname:
        return "j5"
    else:
        return "prod"

def GetWWWURL(new_path):

    env = "prod"
    if env == "prod":
        www_host = "www.hightail.com"
    else:
        www_host = "www." + env + ".htspaces.com"

    return { 'status_code': 301, 'location': "https://" + www_host + new_path }
    
def GetSpacesURL(**options):
	
    env = "prod"
    if env == "prod":
        spaces_host = "spaces.hightail.com"
    else:
        spaces_host = "spaces." + env + ".htspaces.com"

    # Downloads
    if 'ufid' in options:
        ufid = options['ufid']
        assert len(ufid) >= 16, "Invalid UFID '{}'".format(ufid)
        new_path = "/resolve/ufid/" + ufid
    if 'batch_id' in options:
        batch_id = options['batch_id']
        assert len(batch_id) >= 22, "Invalid Batch ID '{}'".format(batch_id)
        new_path = "/resolve/download/" + batch_id

    # Uplink
    if 'uplink_name' in options:
        new_path = "/resolve/u/" + options['uplink_name']

    # Send
    if 'send_id' in options and 'email_id' in options:
        send_id = options['send_id']
        email_id = options['email_id']
        assert len(send_id) >= 9, "Invalid Send ID '{}'".format(send_id)
        assert len(email_id) == 32, "Invalid Email ID '{}'".format(email_id)
        new_path = "/resolve/" + send_id + "/" + email_id

    # Shared Folder
    if 'share_id' in options:
        share_id = options['share_id']
        assert len(share_id) == 43, "Invalid Shared Folder ID '{}'".format(share_id)
        new_path = "/share-accept/" + share_id
        if 'sharee' in options:
            sharee = options['sharee']
            assert "@" in sharee, "Invalid Sharee e-mail address '{}'".format(sharee)
            new_path += "?email=" + sharee

    return { 'status_code': 301, 'location': "https://" + spaces_host + new_path }
    
def GetThirdPartyURL(url):
	
    return { 'status_code': 301, 'location': url }
        
def ProxyHTTPConnection(hostname, path = "/", port = 80, timeout = 3):
	
    if port == 443:
        conn = http.client.HTTPSConnection(hostname, port, timeout)
    else:
        conn = http.client.HTTPConnection(hostname, port, timeout)
    conn.request("GET", path)
    resp = conn.getresponse()
    status_code = resp.status
    content_type = resp.headers["Content-Type"]
    body = resp.read()
    conn.close()
  
    return { 'status_code': status_code, 'content-type': content_type, 'body': body }

def ParseOldURL(hostname = "localhost", path = "/", query_fields = {}):

    import re
	
    env = GetEnvironment(hostname)
    
    # v2PHP Downloads
    if hostname.startswith("download.") and path != "/":
       return GetSpacesURL( **{'ufid': path.replace("/","")} )


    # Uplink / Dropbox handling
    if path.startswith("/u/"):
        return GetSpacesURL( **{'uplink_name': path[3:]} )
    if hostname.startswith("dropbox.") and path != "/":
        return GetSpacesURL( **{'uplink_name': path.replace("/","")} )
    if path.startswith("/dropbox") and "dropbox" in query_fields:
        return GetSpacesURL( **{'uplink_name': query_fields['dropbox']} )

    # Send handling
    if hostname.startswith("rcpt.") and path != "/":
        if path[10] == "/" or path[11] == "/":
            return GetSpacesURL( **{'send_id': path.split("/")[1], 'email_id': path.split("/")[2][:32]} )

    # Shared Folder
    if path.startswith("/sharedFolder") and "phi_action" in query_fields:
        if "id" in query_fields:
            if "sharee" in query_fields:
                return GetSpacesURL( **{'share_id': query_fields['id'], 'sharee': query_fields['sharee']} )
            else:
                return GetSpacesURL( **{'share_id': query_fields['id']} )

    # Old YSI Marketing blogs and press releases
    if hostname.startswith("blog.") or path.startswith("/cms/"):
        return GetThirdPartyURL("https://blog.hightail.com")
            
    # Old SmartLing sites
    if re.match(r"fr|nl|it|de|es", hostname):
        return GetWWWURL(path)

    # Redirect to www if more specific match not found below
    if hostname == "hightail.com" or "yousendit.com" in hostname or "ysi" in hostname:
        return GetWWWURL(path)


    #return GetWWWURL("/foo")

    return { 'status_code': 418, 'content_type': 'text/plain', 'body': 'Hightail / YSI Legacy Redirector Function' }
#
# AWS Lambda Entry Point
def lambda_handler(event, context):

    import base64

    # Set some handy variables
    http_hostname = event['headers']['host']
    http_path = event['path']
    http_query_string = event['queryStringParameters']

    # Return an HTTP response
    sys.stderr = sys.stdout
    sys.tracebacklimit = 0
    try:
        r = ParseURL(http_hostname, http_path, http_query_string)
        if 301 <= r['status_code'] <= 302:
            return {
                'statusCode': r['status_code'],
                'headers': { 'Location': r['location']}
            }
        else:
            is_binary = False
            if not content_type.starts_with("text"):
                is_binary = True
                body = base64.b64encode(body).decode("utf-8")
            return {
                'isBase64Encoded': is_binary,
                'statusCode': status_code,
                'headers': { 'Content-Type': content_type },
                'body': body
            }
    except Exception:
        return {
            'statusCode': 500,
            'headers': { 'Content-Type': 'text/plain' },
            'body': traceback.format_exc() 
        }
    quit()

# Python CGI Script execution
def main():

    import os
    import cgi

    sys.stderr = sys.stdout
    sys.tracebacklimit = 1

    # Retrieve some HTTP headers as variables
    http_hostname = os.environ.get('HTTP_HOST', 'localhost')
    request_uri = os.environ.get('REQUEST_URI', '/')
    http_path = request_uri.split('?')[0]
    http_query_fields = {}

    # Normalize dictionary from cgi.FieldStorage()
    query_fields_objects = cgi.FieldStorage()
    for key in query_fields_objects:
        http_query_fields[key] = str(query_fields_objects[key].value)

    # Get an HTTP response based on the old URL
    try:
        r = ParseOldURL(http_hostname, http_path, http_query_fields)
        if 301 <= r['status_code'] <= 302:
            print("Status: {} Moved Permanently\nLocation: {}\n".format(r['status_code'], r['location']))
        else:
            print("Status: {}\nContent-Type: {}\n".format(r['status_code'], r['content_type']))
            if r['content_type'].startswith("text"):
                print("\n" + r['body'])
            else:
                sys.stdout.flush() 
                sys.stdout.buffer.write(r.body)

    except Exception:
        print("Status: 500\nContent-Type: text/plain\n")
        exc = traceback.format_exc()
        print(exc)

if __name__ == "__main__":
    main()
    quit()
